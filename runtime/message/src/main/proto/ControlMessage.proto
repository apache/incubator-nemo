//
// Licensed to the Apache Software Foundation (ASF) under one
// or more contributor license agreements.  See the NOTICE file
// distributed with this work for additional information
// regarding copyright ownership.  The ASF licenses this file
// to you under the Apache License, Version 2.0 (the // "License"); you may not use this file except in compliance
// with the License.  You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing,
// software distributed under the License is distributed on an
// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
// KIND, either express or implied.  See the License for the
// specific language governing permissions and limitations
// under the License.
//
syntax = "proto2";

package protobuf;

option java_package = "org.apache.nemo.runtime.common.comm";
option java_outer_classname = "ControlMessage";

enum ClientToDriverMessageType {
    LaunchDAG = 0;
    DriverShutdown = 1;
    Scaling = 2;
}

message ClientToDriverMessage {
    required ClientToDriverMessageType type = 1;
    optional LaunchDAGMessage launchDAG = 2;
    optional ScalingMessage scalingMsg = 3;
}

message LaunchDAGMessage {
    required string dag = 1;
    optional bytes broadcastVars = 2;
}

message ScalingMessage {
  required string decision = 1;
  optional double divide = 2;
  optional int32 query = 3;
  repeated double stageRatio = 4;
  optional string info = 5;
}

message DataCollectMessage {
    required string data = 1;
}

enum DriverToClientMessageType {
    DriverStarted = 0;
    DriverReady = 1;
    DataCollected = 2;
    ExecutionDone = 3;
    DriverShutdowned = 4;
    KillAll = 5;
}

message NameLookupMessage {
  required string identifier = 1;
}

message NameRegisterMessage {
  required string identifier = 1;
  required bytes inet = 2;
}

message NameLookupResponse {
  required bytes inet  = 1;
}

message DriverToClientMessage {
    required DriverToClientMessageType type = 1;
    optional DataCollectMessage dataCollected = 2;
}

message ConditionalRoutingMessage {
  required double percent = 1;
  required bool toPartial = 2;
}

enum MessageType {
    TaskStateChanged = 0;
    ScheduleTask = 1;
    BlockStateChanged = 2;
    RunTimePassMessage = 3;
    RequestBlockLocation = 4;
    BlockLocationInfo = 5;
    ExecutorFailed = 6;
    ExecutorDataCollected = 7;
    MetricMessageReceived = 8;
    RequestMetricFlush = 9;
    MetricFlushed = 10;
    RequestBroadcastVariable = 11;
    InMasterBroadcastVariable = 12;
    PipeInit = 13;
    RequestPipeLoc = 14;
    PipeLocInfo = 15;
    RequestTaskIndex = 16;
    TaskIndexInfo = 17;
    RequestTransferIndex = 18;
    TransferIndexInfo = 19;
    RequestStageOffloading = 20;
    RequestStageOffloadingDone = 21;
    StageOffloadingInfo = 22;

    // master - worker scaling
    RequestScaling = 23; // master -> worker
    LocalScalingReadyDone = 24; // worker -> master
    GlobalScalingReadyDone = 25; // master -> worker
    //RequestScalingIn = 26; // master -> worker
    LocalRelayServerInfo = 27; // worker -> master
    GlobalRelayServerInfo = 28; // master -> worker

    LocalExecutorAddressInfo = 29; // worker -> master
    GlobalExecutorAddressInfo = 30; // master -> worker

    // Stat
    TaskStatSignal = 31; // worker -> master

    BroadcastInfo = 32; // master -> worker

    Throttling = 33;

    // for trasnfer index
    RegisterTransferIndex = 34; // worker -> master
    LookupTransferIndex = 35; // worker -> master
    ReturnTransferIndex = 36; // master -> worker

    // for serializer index
    RegisterSerializerIndex = 37; // worker -> master
    LookupSerializerIndex = 38; // worker -> master
    ReturnSerializerIndex = 39; // master -> worker


    // For task migration
    StopTask = 40; // master -> worker
    StopTaskDone = 41; // worker -> master


    // Master -> worker
    ExecutorRegistered = 42;
    ExecutorRemoved = 43;
    TaskScheduled = 46;
    CreateOffloadingExecutor = 49;
    OffloadingTask = 50;
    ResponseOffloadingExecutor = 52;
    ThrottleSource = 53;
    DeoffloadingTask = 54;

    // Worker -> master
    CurrentExecutor = 44;
    CurrentScheduledTask = 45;
    RequestPipeKey = 47;
    TaskExecuting = 48;

    RequestOffloadingExecutor = 51;

    LambdaCreate = 55;
    LambdaControlChannel = 56;

    TaskSendToLambda = 57;
    LambdaEnd = 58;

    ExecutorPreparedForLambda = 59;
    SendBursty = 60;
    FinishBursty = 61;
    InvokePartialOffloading = 62;

    // for registeration
    InitRegistration = 63;

    NameLookup = 64;

    LatencyCollection = 65;

    ConditionalRouting = 66;

    // routing data from VM to lambda
    RoutingDataToLambda = 67;
    RoutingDataDoneToLambda = 68;

    // for CR
    GetStateSignal = 69;

    DeactivateLambdaTask = 70;

    InputStart = 71;
    TaskOutputStart = 72;
    R3PairInputOutputStart = 73;
    R2Init = 74;
    R3OptSignalFinalCombine = 75;
    R3PairTaskInitiateProtocol = 76;
    R3AckPairTaskInitiateProtocol = 77;

    SourceSleep = 78;
    CancelAndSourceSleep = 79;
    ScheduleCachedTask = 80;

    ExecutorMetric = 81;
    SourceEvent = 82;
}

message LambdaEndMessage {
  required int64 requestId = 1;
}

message TaskSendToLambdaMessage {
  required int64 requestId = 1;
  required string taskId = 2;
}

message GetLambdaControlChannel {
  required string fullAddr = 1;
  required int64 requestId = 2;
}

message LambdaCreateMessage {
  required string executorId = 1;
  required string dataChannelAddr = 2;
  required int64 dataChannelPort = 3;
  required int64 nettyStatePort = 4;
  required int64 numberOfLambda = 5;
}

message Message {
    required MessageType type = 1;
    required int64 id = 2;
    required int32 listenerId = 3; // The id of the message listener (handler).
    optional TaskStateChangedMsg taskStateChangedMsg = 4;
    optional ScheduleTaskMsg scheduleTaskMsg = 5;
    optional BlockStateChangedMsg blockStateChangedMsg = 6;
    optional RunTimePassMessageMsg runTimePassMessageMsg = 7;
    optional RequestBlockLocationMsg requestBlockLocationMsg = 8;
    optional BlockLocationInfoMsg blockLocationInfoMsg = 9;
    optional ExecutorFailedMsg executorFailedMsg = 10;
    optional ContainerFailedMsg containerFailedMsg = 11;
    optional MetricMsg metricMsg = 12;
    optional DataCollectMessage dataCollected = 13;
    optional RequestBroadcastVariableMessage requestbroadcastVariableMsg = 14;
    optional InMasterBroadcastVariableMessage broadcastVariableMsg = 15;
    optional PipeInitMessage pipeInitMsg = 16;
    optional RequestPipeLocationMessage requestPipeLocMsg = 17;
    optional PipeLocationInfoMessage pipeLocInfoMsg = 18;
    optional RequestTaskIndexMessage requestTaskIndexMsg = 19;
    optional TaskIndexInfoMessage taskIndexInfoMsg = 20;
    optional RequestTransferIndexMessage requestTransferIndexMsg = 21;
    optional TransferIndexInfoMessage transferIndexInfoMsg = 22;
    optional RequestStageOffloadingMessage requestStageOffloadingMsg = 23;
    optional RequestStageOffloadingDoneMessage requestStageOffloadingDoneMsg = 24;
    optional StageOffloadingInfoMessage stageOffloadingInfoMsg = 25;
    optional RequestScalingMessage requestScalingMsg = 26;
    optional LocalScalingDoneMessage localScalingDoneMsg = 27;
    optional GlobalScalingDoneMessage globalScalingDoneMsg = 28;
    optional LocalRelayServerInfoMessage localRelayServerInfoMsg = 29;
    optional GlobalRelayServerInfoMessage globalRelayServerInfoMsg = 30;
    optional LocalExecutorAddressInfoMessage localExecutorAddressInfoMsg = 31;
    optional GlobalExecutorAddressInfoMessage globalExecutorAddressInfoMsg = 32;

    optional TaskStatMessage taskStatMsg = 33;

    optional BroadcastInfoMessage broadcastInfoMsg = 34;

    optional RegisterTransferIndexMessage registerTransferIndexMsg = 35;
    optional LookupTransferIndexMesssage lookupTransferIndexMsg = 36;
    optional ReturnTransferIndexMessage returnTransferIndexMsg = 37;

    optional RegisterSerializerMessage registerSerializerMsg = 38;
    optional LookupSerializerMesssage lookupSerializerMsg = 39;
    optional ReturnSerializerMessage returnSerializerMsg = 40;

    optional StopTaskMessage stopTaskMsg = 41;
    optional StopTaskDoneMessage stopTaskDoneMsg = 42;

    optional string registeredExecutor = 43;
    repeated string currExecutors = 44;
    repeated string currScheduledTasks = 45;

    optional RequestPipeKeyMessage requestPipeKeyMsg = 46;
    optional ResponsePipeKeyMessage responsePipeKeyMsg = 47;

    optional TaskExecutingMessage taskExecutingMsg = 48;

    optional OffloadingTaskMessage offloadingTaskMsg = 49;

    optional RequestOffloadingExecutorMessage requestOffloadingExecutorMsg = 50;

    optional int64 setNum = 51;

    optional LambdaCreateMessage lambdaCreateMsg = 52;
    optional GetLambdaControlChannel getLambaControlChannelMsg = 53;

    optional TaskSendToLambdaMessage taskSendToLambdaMsg = 54;
    optional LambdaEndMessage lambdaEndMsg = 55;

    optional string senderId = 56;

    optional NameLookupMessage nameLookupMsg = 57;
    optional NameLookupResponse nameLookupResponse = 58;
    optional NameRegisterMessage nameRegisterMsg = 59;

    optional LatencyCollectionMessage latencyMsg = 60;

    optional ConditionalRoutingMessage conditionalRoutingMsg = 61;

    optional ExecutorMetricMsg executorMetricMsg = 62;
}

message ExecutorMetricMsg {
  required string executorId = 1;
  required int64 receiveEvent = 2;
  required int64 processEvent = 3;
  required double cpuUse = 4;
}

message LatencyCollectionMessage {
    required string executorId = 1;
    required int64 latency = 2;
}

message RequestOffloadingExecutorMessage {
  required int64 port = 1;
  required string name = 2;
  required string executorId = 3;
}

message OffloadingTaskMessage {
  required int64 numOffloadingTask = 1;
  required int64 offloadingStage = 2;
}

message TaskExecutingMessage {
  required string executorId = 1;
  required string taskId = 2;
}

message BroadcastInfoMessage {
  required string info = 1;
}

// Messages from Master to Executors
message ScheduleTaskMsg {
    required bytes task = 1;
}

message BlockLocationInfoMsg {
    required int64 requestId = 1; // To find the matching request msg
    required string blockId = 2;
    optional BlockStateFromExecutor state = 3;
    optional string ownerExecutorId = 4;
}

// Messages from Executors to Master
message TaskStateChangedMsg {
    required string executorId = 1;
    required string taskId = 2;
    required TaskStateFromExecutor state = 3;
    optional string vertexPutOnHoldId = 4;
    optional RecoverableFailureCause failureCause = 5;
    required int32 attemptIdx = 6;
}

enum RecoverableFailureCause {
    InputReadFailure = 0;
    OutputWriteFailure = 1;
    // There is a 3rd cause: container_failure, but this is omitted here as it is never propagated with a control msg.
}

message BlockStateChangedMsg {
    required string executorId = 1;
    required string blockId = 2;
    required BlockStateFromExecutor state = 3;
    required string location = 4; // The location of the block (e.g., executor id or remote store).
}

message RunTimePassMessageMsg {
    required string taskId = 1;
    repeated RunTimePassMessageEntry entry = 2;
}

message RunTimePassMessageEntry {
    required string key = 1;
    required int64 value = 2;
}

message RequestBlockLocationMsg {
    required string executorId = 1;
    required string blockIdWildcard = 2;
}

message ExecutorFailedMsg {
    required string executorId = 1;
    required bytes exception = 2;
}

message ContainerFailedMsg {
    required string executorId = 1;
}

message MetricMsg {
    repeated Metric metric = 1;
}

// Messages between Executors

/*
enum ByteTransferDataDirection {
    INITIATOR_SENDS_DATA = 0;
    INITIATOR_RECEIVES_DATA = 1;
}

message ByteTransferContextSetupMessage {
    required string initiatorExecutorId = 1;
    required int32 transferIndex = 2;
    required ByteTransferDataDirection dataDirection = 3;
    required bytes contextDescriptor = 4;
    required bool isPipe = 5;
}
*/

message BlockTransferContextDescriptor {
    required string blockId = 1;
    required BlockStore blockStore = 2;
    required string runtimeEdgeId = 3;
    optional bytes keyRange = 4;
}

/*
message PipeTransferContextDescriptor {
  required int64 srcTaskIndex = 1;
  required string runtimeEdgeId = 2;
  required int64 dstTaskIndex = 3;
  required int64 numPipeToWait = 4;
}
*/

enum TaskStateFromExecutor {
    READY = 0;
    EXECUTING = 1;
    COMPLETE = 2;
    FAILED_RECOVERABLE = 3;
    FAILED_UNRECOVERABLE = 4;
    ON_HOLD = 5;
}

enum BlockStateFromExecutor {
    NOT_AVAILABLE = 0;
    IN_PROGRESS = 1;
    AVAILABLE = 2;
}

enum BlockStore {
    MEMORY = 0;
    SER_MEMORY = 1;
    LOCAL_FILE = 2;
    REMOTE_FILE = 3;
}

// Common messages
message Metric {
    required string metricType = 1;
    required string metricId = 2;
    required string metricField = 3;
    required bytes metricValue = 4;
}

message RequestBroadcastVariableMessage {
  required string executorId = 1;
  required bytes broadcastId = 2;
}

message InMasterBroadcastVariableMessage {
  required int64 requestId = 1; // To find the matching request msg
  required bytes variable = 2;
}

message PipeInitMessage {
  optional int64 srcTaskIndex = 1;
  optional int64 dstTaskIndex = 2;
  required string runtimeEdgeId = 3;
  required string executorId = 4;
}

message RequestPipeLocationMessage {
  required string executorId = 1;
  optional int64 srcTaskIndex = 2;
  required string runtimeEdgeId = 3;
  optional int64 dstTaskIndex = 4;
}

message PipeLocationInfoMessage {
  required int64 requestId = 1; // To find the matching request msg
  required string executorId = 2;
}


message RequestTaskIndexMessage {
  required string srcTaskId = 1;
  required string edgeId = 2;
  required string dstTaskId = 3;
}

message RequestPipeKeyMessage {
  required int64 pipeIndex = 1;
}

message TaskIndexInfoMessage {
  required int64 requestId = 1; // To find the matching request msg
  required int64 taskIndex = 2;
}

message ResponsePipeKeyMessage {
  required string srcTask = 1; // To find the matching request msg
  required string edgeId = 2;
  required string dstTask = 3;
}

message RequestTransferIndexMessage {
  required string executorId = 1;
  required int64 isInputContext = 2;
}

message TransferIndexInfoMessage {
  required int64 requestId = 1; // To find the matching request msg
  required int64 index = 2;
}

message RequestStageOffloadingMessage {
  required string executorId = 1;
  required string stageId = 2;
}

message RequestStageOffloadingDoneMessage {
  required string executorId = 1;
  required string stageId = 2;
}

message StageOffloadingInfoMessage {
  required int64 requestId = 1; // To find the matching request msg
  required bool canOffloading = 2;
}

message RequestScalingMessage {
  required int64 requestId = 1;
  required bool isScaleOut = 2;
  repeated RequestScalingEntryMessage entry = 3;
  repeated TaskLocation taskLocation = 4;
  repeated TaskExecutorIdEntryMessage taskExecutorId = 5;
  optional double divideNum = 6;
  optional bool moveToVmScaling = 7;
  repeated LocalExecutorAddressInfoMessage executorAddrInfos = 8;
}

message TaskLocation {
  required string taskId = 1;
  required int64 location = 2; // 0: vm, 1: sf, 2: vm-scaling
}

message RequestScalingEntryMessage {
  required string stageId = 1;
  repeated string offloadTasks = 2;
}

message TaskExecutorIdEntryMessage {
  required string taskId = 1;
  required string executorId = 2;
}

message ScalingDoneEntryMessage {
  required string stageId = 1;
  required int32 doneNum = 2;
}

message LocalScalingDoneMessage {
  required string executorId = 1;
  required int32 type = 2;
  repeated string offloadedTasks = 3;
}

message TaskStatMessage {
  required string executorId = 1;
  repeated TaskStatInfo taskStats = 2;
  optional double cpuUse = 3;
  optional double sfCpuUse = 4;
}

message TaskStatInfo {
  required string taskId = 1;
  required int32 numKeys = 2;
  required int64 computation = 3;
  required int64 inputElements = 4;
  required int64 outputElements = 5;
}

message GlobalScalingDoneMessage {
  required int64 requestId = 1;
  repeated string offloadedTasks = 2;
}

message LocalRelayServerInfoMessage {
  required string executorId = 1;
  required string address = 2;
  required int32 port = 3;
}

message GlobalRelayServerInfoMessage {
  repeated LocalRelayServerInfoMessage infos = 1;
  required string rendevousAddress = 2;
  required int32 rendevousPort = 3;
}

message LocalExecutorAddressInfoMessage {
  required string executorId = 1;
  required string address = 2;
  required int32 port = 3;
}

message GlobalExecutorAddressInfoMessage {
  repeated LocalExecutorAddressInfoMessage infos = 1;
  repeated string vmAddresses = 2;
  repeated string vmIds = 3;
}

message TransferKeyProto {
  required string edgeId = 1;
  required int32 srcTaskIndex = 2;
  required int32 dstTaskIndex = 3;
  required bool isOutputTransfer = 4;
}

message RegisterTransferIndexMessage {
  required TransferKeyProto key = 1;
  required int32 index = 2;
}

message ReturnTransferIndexMessage {
  required int32 index = 1;
}

message LookupTransferIndexMesssage {
  required TransferKeyProto key = 1;
}

message RegisterSerializerMessage {
  required string runtimeEdgeId = 1;
  required bytes serializer = 2;
}

message ReturnSerializerMessage {
  required bytes serializer = 1;
}

message LookupSerializerMesssage {
  required string runtimeEdgeId = 1;
}

message StopTaskMessage {
  required string taskId = 1;
  optional bytes b = 2;
  optional bool checkpoint = 3;
}

message StopTaskDoneMessage {
  required string taskId = 1;
  required string executorId = 2;
}
